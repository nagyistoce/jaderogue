#summary Getting started with jaderogue is easy!

= Console =

All the code for this tutorial can be found in the file Demo.java and should be enough to get you started. Of course this assumes you have a working knowledge of java.

With the excellent API of Java, it is a great language for roguelike developement. However, it doesn't handle blocked keyboard input nearly as easily. With jade console, these difficulties disappear. While not identical to curses, you'll find the api fairly simple to use. So lets get started!
{{{
	console = Console.getFramedConsole("Demo");
}}}
While we have access to a constructor, and could place the Console in any container we choose, this method wraps the console in a JFrame for conveinence.
{{{
	console.buffChar(0, 0, '@', Color.white);
	console.refreshScreen();
}}}
Here is our basic method for output. BuffChar(..) has a few different signatures but they all do the same thing. Note also that without refreshScreen() nothing shows up. The "buff" methods only manipulate the buffer, while refreshScreen actually draws the buffer.
{{{
	World world = new DemoWorld();
	GenFactory.traditional().generate(world, System.currentTimeMillis());
}}}
These two lines are all we need to generate a new world for our little demo. We will examine the DemoWorld class in a bit, but notice how easy it is to generate a map once we have a world. GenFactory gives you access to a few different algorithms, but you are welcome to implement the Gen interface yourself if the default generation algorithms don't suit you.
{{{
	Actor hero = new DemoActor();
	world.addActor(hero, Dice.global);	
}}}
Actors, in addition to the World, are the basic building blocks of a Jade roguelike. They can represent anything from monsters, items, spells, traps, or even more abstract things like game events and timers. We will examine this class a little more in depth latter on. Also note that this particular version accepts a Dice class, which is a random number generator. Here we just pass in the global instance, but you may want to keep separate instances around for such things. You could also use other versions of addActor to place the Actor where ever you please.
{{{
	while(!hero.isExpired())
	{
		displayWorld(world);
		world.tick();
	}
}}}
This is your standard game loop. You display the world, and then proceed a tick. The method tick() is an abstract method in the Jade World. It should contain logic like moving Actors, remove dead Actors and so forth.
{{{
	private static void displayWorld(World world)
	{
		console.clearBuffer();
		for(int x = 0; x < world.width; x++)
			for(int y = 0; y < world.height; y++)
				console.buffChar(x, y, world.look(x, y));
		console.refreshScreen();
	}
}}}
This is a pretty standard drawing method. There are more advanced ways of doing this such as Jade Cameras and Jade FoV, but that will be covered later. Note that for this to be interesting, you might want to override the lookAll(..) method, but more on that in a bit.
{{{
	public void tick()
	{
		for(DemoActor actor : getActors(DemoActor.class))
			actor.act();
		for(DemoTrap trap : getActors(DemoTrap.class))
			trap.act();
		removeExpired();
	}
}}}
Here is the tick() method from our DemoWorld class. It calls the act() method on the appropriate actors, and then cleans up by calling removeExpired(). Being expired basically means dead, so these Actors should be removed. Also note the getActors(..) method. It takes a class and will return all the Actors on the world of that type. Check out the documentation on getActorsAt(..) and getActorAt(..) for some pretty usefull stuff as well.
{{{
	public void act()
	{
		char key = console.getKey();
		Direction dir = Tools.keyToDir(key, true, false);
		if(dir != null)
			move(dir);
	}
}}}
Here we have the act() method from the DemoActor class. It waits for user input then moves based on that input. You could use a big switch statement around the key and move by two ints dx and dy, or move by a Coord, but this seemed the easiest way to move a single tile. Of course, your game might include more complex logic like checking for obstacles (this guy can go through walls!), monsters using world().getActorAt(..) or casting spells or what ever. This is just a basic act() method. The monsters would put their ai code here as well. 
{{{
	public List<ColoredChar> lookAll(int x, int y)
	{
		List<ColoredChar> look = super.lookAll(x, y);
		DemoTrap trap = getActorAt(x, y, DemoTrap.class);
		if(trap != null)
			look.add(trap.look());
		DemoActor actor = getActorAt(x, y, DemoActor.class);
		if(actor != null)
			look.add(actor.look());
		return look;
	}
}}}
As mentioned before the World should generally override the method lookAll(..) or it will simple display the tile of that location. Once this method is overridden and a draw order established, you can call look and it will correctly display the top face. To use lookAll correctly, call super.lookAll, then append any other faces that should show up starting with the lowest priority in the draw order.
{{{
	public void act()
	{
		if(!held())
		{
			DemoActor hero = world().getActorAt(pos(), DemoActor.class);
			if(hero != null)
				attachTo(hero);
		}
		else
		{
			if(timer-- == 0)
				holder().expire();
		}
	}
}}}
Here is the act() method of the DemoTrap. It is quite diabolical! The method held() returns true if the actor is attached to another. This means that where ever the holder goes, the attached actor goes too. In this case, if the DemoTrap is not held, it tries to attach itself to a DemoActor. If it is held, it counts down to 0 and then expire (kills) the holder. It is then the world's responsability to remove that Actor (unless you want a zombie or something). Attaching can be very powerful. You want a timed spell? Use actors. You want items to stay with its owner? Use actors. You want timers? Use an actor. They are not just the players and monsters.
{{{
	private static void displayWorld2(World world, Actor actor)
	{
		Collection<Coord> fov = FoVFactory.rayCircle().calcFoV(actor, 10);
		console.clearBuffer();
		for(Coord coord : fov)
			console.buffChar(coord, world.look(coord));
		console.refreshScreen();
	}
}}}
Here is a variation of our displayWorld method. The first line is the interesting one. It shows us how to use field of vision. A few different algorithms are already implemented and are retrievable using the FoVFactory. After that you simply make the call to calcFoV(..) and you have all the Coords in vision. Its that easy.

Well, thats probably enough to get you started. There is of course much more to help you out in your roguelike developement, but you will have to check out the documentation to learn more. You can also take a look at my own game in developement to see how I envision using this library. Happy coding!